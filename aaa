# Define the maze as a 2D list with 60 rows and 80 columns
import random
import sys


maze = [['' for j in range(80)] for i in range(60)]
#we can change blank space to 0 or vice versa
# Define the obstacle object
obstacle = '*'
initial = 'I'
goal = 'G'

initial_placerow = random.randint(0,59)
initial_placecolumn = random.randint(0,79)

goal_placerow = random.randint(0,59)
goal_placecolumn = random.randint(0,79)



# Fill the maze with 30% obstacles chosen randomly
for i in range(60):
    for j in range(80):
        if random.random() < 0.3:  # 30% chance of adding an obstacle
            maze[i][j] = obstacle

while maze[initial_placerow][initial_placecolumn] == obstacle:
    print("The initial state is occupied by an obstacle")
    sys.exit()
    #initial_placerow = random.randint(0, 59)
    #initial_placecolumn = random.randint(0, 79)
#maze[initial_placerow][initial_placecolumn] = initial

while maze[goal_placerow][goal_placecolumn] == obstacle:
    print("The  goal state is occupied by an obstacle")
    sys.exit()
    #goal_placerow = random.randint(0, 59)
    #goal_placecolumn = random.randint(0, 79)
#maze[goal_placerow][goal_placecolumn] = goal

# Print the maze
for i in range(60):
    for j in range(80):
        print(maze[i][j], end=' ')

    print()

# Define a function to compute the Euclidean distance between two points which is our heuristic function
def heuristic(point1, point2):
    return ((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)**0.5







# Define the A* algorithm function
def algo(start, goal):
    # Initialize the open and closed sets
    open_set = [start]
    closed_set = []
    parent = {}

    # Initialize the g-score and f-score dictionaries
    g_score = {start: 0}
    f_score = {start: heuristic(start, goal)}

    def get_neighbors(current):
        row, col = current
        neighbors = []
        if row > 0:
            neighbors.append((row - 1, col))
        if row < 59:
            neighbors.append((row + 1, col))
        if col > 0:
            neighbors.append((row, col - 1))
        if col < 79:
            neighbors.append((row, col + 1))
        return neighbors
    # Start the main loop
    while len(open_set) > 0:
        current = None
        lowest_f_score = float('inf')

        for state in open_set:
            if f_score[state] < lowest_f_score:
                current = state
                lowest_f_score = f_score[state]
# the line of code selects the state in open_set that has the lowest f-score,
# and assigns it to the current variable.
            if current == goal:
                # indent the following lines to include the break statement
                open_set.remove(current)
                closed_set.add(current)

            open_set.remove(current)
            closed_set.add(current)
            for neighbor in get_neighbors(current):
                if neighbor in closed_set:
                    continue
                tentative_g_score = g_score[current] + 1
                if neighbor not in open_set:
                    open_set.add(neighbor)
                elif tentative_g_score >= g_score[neighbor]:
                    continue
                parent[neighbor] = current
                g_score[neighbor] = tentative_g_score
                f_score[neighbor] = g_score[neighbor] + heuristic(neighbor[0], neighbor[1], goal_placerow,
                                                                  goal_placecolumn)


            # Print the maze with the optimal path
            if goal in parent:
                current = goal
                while current != initial:
                    maze[current[0]][current[1]] = '+'
                    current = parent[current]
                maze[initial_placerow][initial_placecolumn] = 'I'
                maze[goal_placerow][goal_placecolumn] = 'G'
                for i in range(60):
                    for j in range(80):
                        print(maze[i][j], end='')
                    print()
            else:
                for i in range(60):
                    for j in range(80):
                        print(maze[i][j], end='')
                    print()
                print("The goal state is not reachable from the initial state.")



